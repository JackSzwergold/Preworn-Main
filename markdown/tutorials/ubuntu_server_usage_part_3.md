# Using an Ubuntu Linux Server

Written by [Jack Szwergold][1] on April 6, 2014

## Part 3: Monitoring & Securing Your Ubuntu Server

In part 3 of my tutorial I will explain how to setup useful monitoring & security tools. You should never be in a situation where you cannot be able to review & assess server health. Being able to monitor & secure your server is the key to running a safe & stable server environment. 

### Install the ‘munin’ to monitor system vitals.

The best way to keep running tabs on your server’s overall health is to use `munin`. It basically keeps a running, web accessible visual log of your server’s overall health. Thing of it as an EKG for your server. To use it, first install it like so:

    sudo aptitude install munin munin-node

If you notice we are installing `munin` itself as well as `munin-node` since `munin` can act as a centralized hub for the data `munin-node` generates. In this case we are going to host `munin` and `munin-node` on the same server.

Now, when `munin` is installed, it sets up a symbolic link from it’s default `apache` config to the real `apache` config area. I’m not so into that. So I like to remove that symbolic link:

    sudo rm /etc/apache2/conf.d/munin

Create a new `munin.conf` file like so:

    sudo nano /etc/apache2/conf.d/munin.conf

Then add this to that file:

    <Directory "/var/cache/munin/www">
      Options Indexes MultiViews FollowSymLinks
      AllowOverride None

      <IfModule mod_expires.c>
        ExpiresActive On
        ExpiresDefault M310
      </IfModule>

    </Directory>

Now wait about 10-15 minutes, restart `apache`:

    sudo service apache2 restart

And go to the default host or IP of your web server like so:

    http://192.168.56.10/munin

You should now see the beginnings of some Munin charts. Which is great! But let’s tune a few things first, such as activating some `apache`, `mysql` & `postfix` specific `munin` plugins like so:

    sudo ln -s /usr/share/munin/plugins/apache_accesses /etc/munin/plugins/apache_accesses
    sudo ln -s /usr/share/munin/plugins/apache_processes /etc/munin/plugins/apache_processes
    sudo ln -s /usr/share/munin/plugins/apache_volume /etc/munin/plugins/apache_volume
    sudo ln -s /usr/share/munin/plugins/mysql_bytes /etc/munin/plugins/mysql_bytes
    sudo ln -s /usr/share/munin/plugins/mysql_innodb /etc/munin/plugins/mysql_innodb
    sudo ln -s /usr/share/munin/plugins/mysql_queries /etc/munin/plugins/mysql_queries
    sudo ln -s /usr/share/munin/plugins/mysql_slowqueries /etc/munin/plugins/mysql_slowqueries
    sudo ln -s /usr/share/munin/plugins/mysql_threads /etc/munin/plugins/mysql_threads
    sudo ln -s /usr/share/munin/plugins/postfix_mailqueue /etc/munin/plugins/postfix_mailqueue
    sudo ln -s /usr/share/munin/plugins/postfix_mailvolume /etc/munin/plugins/postfix_mailvolume

And restart `munin-node` for the changes to take effect:

    sudo service munin-node restart

Now there is an annoying bug in `munin` that will cause it to report InnoDB free tablespace to be low even when `autoextend` for MySQL is active. A complete false positive scenario that will drive you nuts if you have e-mail alerts set up. The solution is to add the following configuration options to your `munin` config like so:

    sudo nano /etc/munin/plugin-conf.d/munin-node

Now scroll to the bottom of the file & add these configuration settings:

    [mysql_innodb]
    env.warning 0
    env.critical 0

And restart `munin-node` for the changes to take effect:

    sudo service munin-node restart




### Install the ‘iptables’ firewall.

Now we’re going to install `iptables`, which is an excellent & widely used software-based firewall.  We’ll also be installing `iptables-persistent` which is a simply companion tool that allows `iptables` to be reloaded & active if/when a server reboots:

    sudo aptitude install iptables iptables-persistent

Next, we’re going to create a very basic set of `iptables` rules to start off with. Below is a simple `iptables` rule set export of a basic setup I like to use:

    # Generated by iptables-save v1.4.12 on Sun Apr  6 11:50:24 2014
    *nat
    :PREROUTING ACCEPT [0:0]
    :INPUT ACCEPT [0:0]
    :OUTPUT ACCEPT [3:198]
    :POSTROUTING ACCEPT [3:198]
    COMMIT
    # Completed on Sun Apr  6 11:50:24 2014
    # Generated by iptables-save v1.4.12 on Sun Apr  6 11:50:24 2014
    *mangle
    :PREROUTING ACCEPT [22:1475]
    :INPUT ACCEPT [22:1475]
    :FORWARD ACCEPT [0:0]
    :OUTPUT ACCEPT [21:3342]
    :POSTROUTING ACCEPT [21:3342]
    COMMIT
    # Completed on Sun Apr  6 11:50:24 2014
    # Generated by iptables-save v1.4.12 on Sun Apr  6 11:50:24 2014
    *filter
    :INPUT ACCEPT [0:0]
    :FORWARD ACCEPT [0:0]
    :OUTPUT ACCEPT [21:3342]
    :SSH_CHECK - [0:0]
    -A INPUT -p tcp -m tcp --dport 22 -m state --state NEW -j SSH_CHECK
    -A INPUT -i lo -j ACCEPT
    -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT
    -A INPUT -p tcp -m tcp --dport 443 -j ACCEPT
    -A INPUT -p icmp -m icmp --icmp-type any -j ACCEPT
    -A INPUT -p esp -j ACCEPT
    -A INPUT -p ah -j ACCEPT
    -A INPUT -d 224.0.0.251/32 -p udp -m udp --dport 5353 -j ACCEPT
    -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
    -A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
    -A INPUT -j REJECT --reject-with icmp-host-prohibited
    -A FORWARD -j TOR
    -A SSH_CHECK -m recent --set --name SSH --rsource
    -A SSH_CHECK -m recent --update --seconds 60 --hitcount 4 --name SSH --rsource -j DROP
    COMMIT
    # Completed on Sun Apr  6 11:50:24 2014

It seems like there is a lot of stuff happening here—and there is—but it’s pretty simple. Here’s a somewhat quick, but wordy explanation but if you don’t need these kind of details just yet, just move onto the next part: The stuff in `*nat` & `*mangle` are boilerplate defaults from an iptables rule set export. The stuff in `*filter` is where the basic cool stuff happens. The important lines in there includes the `SSH_CHECK` which protects against someone “war dialing” your SSH connection. It’s called as part of the `INPUT` chain at the top of the list, but it’s behavior is defined near the bottom of the list. The next set of rules define other sundry `INPUT` points, but the ones you should care about are the rules connected to port `80` as well as `443`. Those open up port `80` which is the basic `http` protocol port used by web servers & port `443` which is used by the `https` protocol used for secure webpage connections. If you need to open up any additional ports on your server, just copy the basic format shown in those two lines & change the port number to match the desired port number you need to have opened.

Now, run this command to immediately load the rules in `iptables.conf` into your server’s `iptables` setup:

    sudo iptables-restore < iptables.conf

Now if you run the following command:

    sudo iptables -L -n

You should see output that looks something like this which reflects all currently active `iptables` rules:

    Chain INPUT (policy ACCEPT)
    target     prot opt source               destination         
    ACCEPT     tcp  --  50.14.92.170         0.0.0.0/0            tcp dpt:22
    SSH_CHECK  tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22 state NEW
    TOR        all  --  0.0.0.0/0            0.0.0.0/0           
    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80
    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:443
    ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0            icmptype 255
    ACCEPT     esp  --  0.0.0.0/0            0.0.0.0/0           
    ACCEPT     ah   --  0.0.0.0/0            0.0.0.0/0           
    ACCEPT     udp  --  0.0.0.0/0            224.0.0.251          udp dpt:5353
    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:22
    REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited

    Chain FORWARD (policy ACCEPT)
    target     prot opt source               destination         
    TOR        all  --  0.0.0.0/0            0.0.0.0/0           

    Chain OUTPUT (policy ACCEPT)
    target     prot opt source               destination         

    Chain SSH_CHECK (1 references)
    target     prot opt source               destination         
               all  --  0.0.0.0/0            0.0.0.0/0            recent: SET name: SSH side: source
    DROP       all  --  0.0.0.0/0            0.0.0.0/0            recent: UPDATE seconds: 60 hit_count: 4 name: SSH side: source

Which is great! But the issue is that if you restart you server, all of your rules will be gone. That is where `iptables-persistent` comes in. And using it is pretty simple.

Just copy the `iptables.conf` file you created just now into `/etc/iptables/rules.v4`:

    sudo cp ~/iptables.conf /etc/iptables/rules.v4

Now when your server restarts, `iptables-persistent` will load all of the rules stored in `/etc/iptables/rules.v4` so your `iptables` rule set will always be active.

[1]: http://www.preworn.com/ "Preworn • Jack Szwergold’s Online Portfolio"